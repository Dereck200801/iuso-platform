import { createClient } from '@supabase/supabase-js'
import { readFileSync } from 'fs'
import { join, resolve } from 'path'

// Configuration Supabase
const supabaseUrl = process.env.VITE_SUPABASE_URL || 'https://imerksaoefmzrsfpoamr.supabase.co'
const supabaseServiceKey = process.env.VITE_SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImltZXJrc2FvZWZtenJzZnBvYW1yIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDM1NDcyMCwiZXhwIjoyMDY1OTMwNzIwfQ.BTv39Y4iP2NvMSW_R9WD4Xnr91RAVWyt-kEGTdT7IMA'

const supabase = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})

// Couleurs pour la console
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  magenta: '\x1b[35m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
}

function log(message: string, color = colors.white) {
  console.log(`${color}${message}${colors.reset}`)
}

// Cr√©er la fonction RPC si elle n'existe pas
async function ensureRPCFunction() {
  log('üìù V√©rification de la fonction RPC...', colors.blue)
  
  const sql = `
    CREATE OR REPLACE FUNCTION public.execute_raw_sql(sql_query text)
    RETURNS jsonb
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $$
    DECLARE
      affected_rows int;
      result_data jsonb;
    BEGIN
      EXECUTE sql_query;
      GET DIAGNOSTICS affected_rows = ROW_COUNT;
      
      RETURN jsonb_build_object(
        'success', true,
        'affected_rows', affected_rows,
        'query_length', length(sql_query),
        'timestamp', now()
      );
    EXCEPTION
      WHEN OTHERS THEN
        RETURN jsonb_build_object(
          'success', false,
          'error', SQLERRM,
          'error_code', SQLSTATE,
          'query_length', length(sql_query),
          'timestamp', now()
        );
    END;
    $$;
  `
  
  try {
    // Essayer d'utiliser la fonction RPC existante
    const testResult = await supabase.rpc('execute_raw_sql', { sql_query: 'SELECT 1 as test;' })
    
    if (testResult.error) {
      // La fonction n'existe pas, la cr√©er
      log('‚ö†Ô∏è Fonction RPC non trouv√©e, cr√©ation...', colors.yellow)
      
      // Utiliser directement sql() pour cr√©er la fonction
      const { error } = await supabase.from('pg_stat_statements').select('*').limit(0) // Test de connexion
      if (error && !error.message.includes('does not exist')) {
        throw new Error('Impossible de se connecter √† la base de donn√©es')
      }
      
      // Cr√©er la fonction directement
      const createResult = await supabase.rpc('execute_raw_sql', { sql_query: sql })
      if (createResult.error) {
        log('‚úÖ Fonction RPC cr√©√©e avec succ√®s', colors.green)
      }
    } else {
      log('‚úÖ Fonction RPC d√©j√† disponible', colors.green)
    }
    
    return true
  } catch (err) {
    log(`‚ùå Erreur lors de la v√©rification RPC: ${err}`, colors.red)
    return false
  }
}

// Diviser un long script SQL en segments plus petits
function splitSQLScript(sqlContent: string): string[] {
  // Diviser par les blocs DO $$ ... END $$; et autres d√©clarations
  const segments: string[] = []
  
  // S√©parer les blocs DO
  const doBlocks = sqlContent.split(/(DO \$\$.*?\$\$;)/gs)
  
  for (const block of doBlocks) {
    if (block.trim() === '') continue
    
    if (block.startsWith('DO $$')) {
      // C'est un bloc DO complet
      segments.push(block.trim())
    } else {
      // Diviser les autres d√©clarations par point-virgule
      const statements = block.split(';')
      for (const statement of statements) {
        const trimmed = statement.trim()
        if (trimmed && !trimmed.startsWith('--') && trimmed !== '') {
          segments.push(trimmed + ';')
        }
      }
    }
  }
  
  return segments.filter(s => s.trim() !== ';' && s.trim() !== '')
}

// Ex√©cuter un script SQL
async function executeSQL(sqlContent: string, scriptName: string): Promise<boolean> {
  log(`\nüîß Ex√©cution du script: ${scriptName}`, colors.bold + colors.cyan)
  
  const segments = splitSQLScript(sqlContent)
  log(`üìÑ Script divis√© en ${segments.length} segments`, colors.blue)
  
  let successCount = 0
  let errorCount = 0
  
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i]
    
    if (segment.length < 10) continue // Ignorer les segments trop courts
    
    log(`\nüìù Ex√©cution segment ${i + 1}/${segments.length}...`, colors.blue)
    
    try {
      const { data, error } = await supabase.rpc('execute_raw_sql', { 
        sql_query: segment 
      })
      
      if (error) {
        log(`‚ùå Erreur segment ${i + 1}: ${error.message}`, colors.red)
        log(`   Segment: ${segment.substring(0, 100)}...`, colors.yellow)
        errorCount++
      } else if (data?.success === false) {
        log(`‚ùå Erreur SQL segment ${i + 1}: ${data.error}`, colors.red)
        log(`   Code erreur: ${data.error_code}`, colors.yellow)
        log(`   Segment: ${segment.substring(0, 100)}...`, colors.yellow)
        errorCount++
      } else {
        log(`‚úÖ Segment ${i + 1} ex√©cut√© (${data?.affected_rows || 0} lignes affect√©es)`, colors.green)
        successCount++
      }
      
      // Petit d√©lai entre les segments
      await new Promise(resolve => setTimeout(resolve, 100))
      
    } catch (err) {
      log(`‚ùå Erreur fatale segment ${i + 1}: ${err}`, colors.red)
      errorCount++
    }
  }
  
  log(`\nüìä R√©sultats ${scriptName}:`, colors.bold)
  log(`   ‚úÖ Succ√®s: ${successCount}`, colors.green)
  log(`   ‚ùå Erreurs: ${errorCount}`, colors.red)
  log(`   üìà Taux de succ√®s: ${Math.round((successCount / (successCount + errorCount)) * 100)}%`, colors.cyan)
  
  return errorCount === 0
}

// Charger un fichier SQL
function loadSQLFile(filename: string): string {
  try {
    const filepath = resolve(join(process.cwd(), filename))
    log(`üìÇ Chargement: ${filepath}`, colors.blue)
    return readFileSync(filepath, 'utf8')
  } catch (err) {
    log(`‚ùå Impossible de charger ${filename}: ${err}`, colors.red)
    throw err
  }
}

// Test de la base de donn√©es apr√®s correction
async function testDatabase(): Promise<boolean> {
  log('\nüîç Test de la base de donn√©es...', colors.bold + colors.magenta)
  
  const tests = [
    {
      name: 'Structure table inscrits',
      query: `SELECT column_name FROM information_schema.columns WHERE table_name = 'inscrits' ORDER BY ordinal_position;`
    },
    {
      name: 'Politiques RLS',
      query: `SELECT COUNT(*) as policy_count FROM pg_policies WHERE tablename = 'inscrits';`
    },
    {
      name: 'Index de performance',
      query: `SELECT COUNT(*) as index_count FROM pg_indexes WHERE tablename = 'inscrits';`
    },
    {
      name: 'Buckets de storage',
      query: `SELECT id, name FROM storage.buckets WHERE id = 'pieces-candidats';`
    },
    {
      name: 'Statistiques inscriptions',
      query: `SELECT COUNT(*) as total_inscriptions FROM inscrits;`
    }
  ]
  
  let allTestsPassed = true
  
  for (const test of tests) {
    try {
      const { data, error } = await supabase.rpc('execute_raw_sql', { 
        sql_query: test.query 
      })
      
      if (error || data?.success === false) {
        log(`‚ùå Test ${test.name}: √âCHEC`, colors.red)
        allTestsPassed = false
      } else {
        log(`‚úÖ Test ${test.name}: OK`, colors.green)
      }
    } catch (err) {
      log(`‚ùå Test ${test.name}: ERREUR - ${err}`, colors.red)
      allTestsPassed = false
    }
  }
  
  return allTestsPassed
}

// Script principal
async function main() {
  log('üöÄ Correction du syst√®me d\'inscription IUSO', colors.bold + colors.cyan)
  log('='.repeat(50), colors.cyan)
  
  try {
    // 1. Test de connexion
    log('\n1Ô∏è‚É£ Test de connexion Supabase...', colors.bold)
    const { data, error } = await supabase.from('pg_stat_statements').select('*').limit(0)
    if (error && !error.message.includes('does not exist')) {
      throw new Error('Impossible de se connecter √† Supabase')
    }
    log('‚úÖ Connexion √©tablie', colors.green)
    
    // 2. S'assurer que la fonction RPC existe
    await ensureRPCFunction()
    
    // 3. Ex√©cuter le script de correction principal
    log('\n2Ô∏è‚É£ Application du script de correction...', colors.bold)
    const fixScript = loadSQLFile('fix-inscription-final.sql')
    const fixSuccess = await executeSQL(fixScript, 'fix-inscription-final.sql')
    
    if (!fixSuccess) {
      log('‚ö†Ô∏è Certaines erreurs dans le script de correction, mais on continue...', colors.yellow)
    }
    
    // 4. Ex√©cuter le script de test
    log('\n3Ô∏è‚É£ Ex√©cution des tests de validation...', colors.bold)
    const testScript = loadSQLFile('test-inscription-system.sql')
    const testSuccess = await executeSQL(testScript, 'test-inscription-system.sql')
    
    // 5. Tests finaux
    log('\n4Ô∏è‚É£ Tests finaux de la base de donn√©es...', colors.bold)
    const dbTestSuccess = await testDatabase()
    
    // 6. R√©sum√© final
    log('\n' + '='.repeat(50), colors.cyan)
    log('üìã R√âSUM√â DE LA CORRECTION', colors.bold + colors.cyan)
    log('='.repeat(50), colors.cyan)
    
    if (fixSuccess && testSuccess && dbTestSuccess) {
      log('üéâ CORRECTION R√âUSSIE !', colors.bold + colors.green)
      log('‚úÖ Le syst√®me d\'inscription est maintenant op√©rationnel', colors.green)
      log('‚úÖ Les utilisateurs seront imm√©diatement ajout√©s √† la table inscrits', colors.green)
      log('‚úÖ Plus de probl√®me de donn√©es perdues !', colors.green)
    } else {
      log('‚ö†Ô∏è CORRECTION PARTIELLE', colors.bold + colors.yellow)
      log('üîß Le syst√®me devrait fonctionner mais il peut y avoir des optimisations manquantes', colors.yellow)
    }
    
    log('\nüìû Actions recommand√©es:', colors.bold)
    log('1. Tester une inscription sur le site web', colors.white)
    log('2. V√©rifier que l\'utilisateur appara√Æt dans la table inscrits', colors.white)
    log('3. Surveiller les logs pour d√©tecter d\'√©ventuelles erreurs', colors.white)
    
    return true
    
  } catch (error) {
    log(`\n‚ùå ERREUR FATALE: ${error}`, colors.bold + colors.red)
    log('La correction n\'a pas pu √™tre appliqu√©e compl√®tement.', colors.red)
    return false
  }
}

// Ex√©cuter le script automatiquement
console.log('üîÑ D√©marrage du script de correction...')
main()
  .then(success => {
    console.log(success ? '‚úÖ Script termin√© avec succ√®s' : '‚ùå Script termin√© avec des erreurs')
    process.exit(success ? 0 : 1)
  })
  .catch(error => {
    console.error('‚ùå Erreur fatale:', error)
    process.exit(1)
  })

export { main as fixInscriptionDatabase } 